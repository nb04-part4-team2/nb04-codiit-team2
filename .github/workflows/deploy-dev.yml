name: Deploy to AWS (Deploy Branch)

on:
  push:
    branches:
      - deploy
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
        default: development

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}
  SECURITY_GROUP_ID: sg-0c8189a7705b897b1
  SUBNET_ID: subnet-033040817684d732a
  IAM_INSTANCE_PROFILE: CodiitEC2Role
  KEY_NAME: codiit-key

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ============================================
      # Step 1: í˜„ì¬ í™œì„± í™˜ê²½ ê°ì§€ (Blue/Green)
      # ============================================
      - name: Detect current active environment
        id: detect
        run: |
          echo "ğŸ” í˜„ì¬ ìš´ì˜ ì¤‘ì¸ í™˜ê²½ ê°ì§€ ì¤‘..."

          CURRENT_TG_ARN=$(aws elbv2 describe-listeners \
            --listener-arns ${{ secrets.ALB_LISTENER_ARN }} \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
            --output text)

          echo "Current Target Group: $CURRENT_TG_ARN"

          if [[ "$CURRENT_TG_ARN" == "${{ secrets.BLUE_TARGET_GROUP_ARN }}" ]]; then
            echo "current_env=blue" >> $GITHUB_OUTPUT
            echo "target_env=green" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-green" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.GREEN_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸ“˜ í˜„ì¬: Blue ìš´ì˜ ì¤‘ â†’ ğŸ“— ë°°í¬ íƒ€ê²Ÿ: Green"
          elif [[ "$CURRENT_TG_ARN" == "${{ secrets.GREEN_TARGET_GROUP_ARN }}" ]]; then
            echo "current_env=green" >> $GITHUB_OUTPUT
            echo "target_env=blue" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-blue" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸ“— í˜„ì¬: Green ìš´ì˜ ì¤‘ â†’ ğŸ“˜ ë°°í¬ íƒ€ê²Ÿ: Blue"
          else
            echo "âš ï¸ No active target group detected. Starting initial deployment."
            echo "current_env=none" >> $GITHUB_OUTPUT
            echo "target_env=blue" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-blue" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸš€ ì²« ë°°í¬: Blue í™˜ê²½ìœ¼ë¡œ ì‹œì‘"
          fi

      # ============================================
      # Step 2: EC2 ì¡´ì¬ í™•ì¸ ë° ìƒì„±
      # ============================================
      - name: Check or create EC2 instance
        id: ec2-setup
        run: |
          echo "ğŸ” Checking for existing ${{ steps.detect.outputs.target_tag }} EC2..."

          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ steps.detect.outputs.target_tag }}" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ "$INSTANCE_ID" == "None" || -z "$INSTANCE_ID" ]]; then
            echo "ğŸ”¨ Creating new EC2 from Golden AMI..."

            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ${{ secrets.GOLDEN_AMI_ID }} \
              --instance-type t2.micro \
              --key-name ${{ env.KEY_NAME }} \
              --security-group-ids ${{ env.SECURITY_GROUP_ID }} \
              --subnet-id ${{ env.SUBNET_ID }} \
              --iam-instance-profile Name=${{ env.IAM_INSTANCE_PROFILE }} \
              --associate-public-ip-address \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${{ steps.detect.outputs.target_tag }}}]" \
              --query 'Instances[0].InstanceId' \
              --output text)

            echo "âœ… EC2 created: $INSTANCE_ID"
            echo "â³ Waiting for instance to be running..."
            aws ec2 wait instance-running --instance-ids $INSTANCE_ID

            echo "â³ Waiting for initialization (90s)..."
            sleep 90
          else
            echo "âœ… Using existing EC2: $INSTANCE_ID"
          fi

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      # ============================================
      # Step 3: EC2 Public IP ë™ì  ì¡°íšŒ
      # ============================================
      - name: Get EC2 Public IP
        id: get-ip
        run: |
          echo "ğŸ” Getting Public IP for ${{ steps.ec2-setup.outputs.instance_id }}..."

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ steps.ec2-setup.outputs.instance_id }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "âœ… Public IP: $PUBLIC_IP"
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      # ============================================
      # Step 4: Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ECR í‘¸ì‹œ
      # ============================================
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                     $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "âœ… Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      # ============================================
      # Step 5: EC2ì— ë°°í¬ (SSH)
      # ============================================
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/codiit-key.pem
          chmod 400 ~/.ssh/codiit-key.pem
          ssh-keyscan -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts

      - name: Create .env file on EC2
        run: |
          echo "ğŸ“ Creating .env file on ${{ steps.detect.outputs.target_env }} EC2..."

          ssh -i ~/.ssh/codiit-key.pem ec2-user@${{ steps.get-ip.outputs.public_ip }} << 'ENVSSH'
          cat > /home/ec2-user/.env << 'ENVFILE'
          NODE_ENV=production
          PORT=3000
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          ACCESS_TOKEN_SECRET=${{ secrets.ACCESS_TOKEN_SECRET }}
          ACCESS_TOKEN_EXPIRES_IN=15m
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          REFRESH_TOKEN_EXPIRES_IN=7d
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          BCRYPT_ROUNDS=10
          AWS_REGION=ap-northeast-2
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          ENVFILE
          ENVSSH

          echo "âœ… .env file created"

      - name: Deploy Docker container on ${{ steps.detect.outputs.target_env }} EC2
        run: |
          echo "ğŸš€ Deploying to ${{ steps.detect.outputs.target_env }} EC2..."

          ssh -i ~/.ssh/codiit-key.pem ec2-user@${{ steps.get-ip.outputs.public_ip }} << 'DEPLOYSSH'
          # ECR ë¡œê·¸ì¸
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

          # ì´ë¯¸ì§€ Pull
          echo "ğŸ“¥ Pulling new image..."
          docker pull ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

          # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ Graceful Shutdown
          echo "ğŸ›‘ Stopping old container (30s graceful)..."
          docker stop --time 30 app || true
          docker rm app || true

          # ìƒˆ ì»¨í…Œì´ë„ˆ ì‹¤í–‰
          echo "â–¶ï¸  Starting new container..."
          docker run -d \
            --name app \
            -p 3000:3000 \
            --restart=always \
            --env-file /home/ec2-user/.env \
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

          # Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
          echo "ğŸ”„ Running Prisma migrations..."
          docker exec app npx prisma migrate deploy

          if [ $? -ne 0 ]; then
            echo "âŒ Migration failed!"
            docker logs app --tail 50
            docker stop app
            docker rm app
            exit 1
          fi
          echo "âœ… Migrations completed"

          # í—¬ìŠ¤ì²´í¬
          echo "ğŸ¥ Health checking..."
          for i in {1..12}; do
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "âœ… Health check passed! (attempt $i/12)"
              exit 0
            fi

            if [ $i -eq 12 ]; then
              echo "âŒ Health check failed after 60s"
              docker logs app --tail 50
              exit 1
            fi

            echo "   â³ Retrying... ($i/12)"
            sleep 5
          done
          DEPLOYSSH

          echo "âœ… Deployment on ${{ steps.detect.outputs.target_env }} EC2 successful!"

      # ============================================
      # Step 6: Target Groupì— EC2 ë“±ë¡
      # ============================================
      - name: Register to Target Group
        run: |
          echo "ğŸ“‹ Registering to Target Group..."

          EXISTING=$(aws elbv2 describe-target-health \
            --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
            --query "TargetHealthDescriptions[?Target.Id=='${{ steps.ec2-setup.outputs.instance_id }}'].Target.Id" \
            --output text)

          if [[ -z "$EXISTING" ]]; then
            aws elbv2 register-targets \
              --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
              --targets Id=${{ steps.ec2-setup.outputs.instance_id }}
            echo "âœ… Target registered"
          else
            echo "â„¹ï¸  Target already registered"
          fi

      - name: Wait for target to be healthy
        run: |
          echo "â³ Waiting for target to be healthy..."

          for i in {1..20}; do
            HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
              --targets Id=${{ steps.ec2-setup.outputs.instance_id }} \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)

            echo "Target health: $HEALTH ($i/20)"

            # Blue-Green ë°°í¬ì—ì„œ ë¹„í™œì„± Target Groupì€ 'unused' ìƒíƒœê°€ ì •ìƒ
            # ALBê°€ í•´ë‹¹ TGë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ Health Checkê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
            # 'unused'ëŠ” ë°°í¬ ì‹¤íŒ¨ê°€ ì•„ë‹ˆë¼ "ëŒ€ê¸° ì¤‘" ìƒíƒœë¥¼ ì˜ë¯¸
            if [[ "$HEALTH" == "healthy" ]] || [[ "$HEALTH" == "unused" ]]; then
              echo "âœ… Target is ready! (Status: $HEALTH)"
              exit 0
            fi

            sleep 15
          done

          echo "âŒ Target did not become healthy"
          exit 1

      # ============================================
      # Step 7: ALB íŠ¸ë˜í”½ ì „í™˜
      # ============================================
      - name: Switch ALB to ${{ steps.detect.outputs.target_env }}
        if: success()
        run: |
          echo "ğŸ”€ ALB íŠ¸ë˜í”½ ì „í™˜ ì¤‘..."
          echo "   ${{ steps.detect.outputs.current_env }} â†’ ${{ steps.detect.outputs.target_env }}"

          aws elbv2 modify-listener \
            --listener-arn ${{ secrets.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ steps.detect.outputs.target_tg_arn }}

          echo "âœ… íŠ¸ë˜í”½ ì „í™˜ ì™„ë£Œ!"
          echo ""
          echo "ğŸ“Š ë°°í¬ ê²°ê³¼:"
          echo "   â€¢ ì´ì „: ${{ steps.detect.outputs.current_env }} (ë¡¤ë°± ëŒ€ê¸°)"
          echo "   â€¢ í˜„ì¬: ${{ steps.detect.outputs.target_env }} (ìš´ì˜ ì¤‘)"
          echo "   â€¢ Instance: ${{ steps.ec2-setup.outputs.instance_id }}"
          echo "   â€¢ IP: ${{ steps.get-ip.outputs.public_ip }}"
          echo "   â€¢ Image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
          echo ""
          echo "ğŸ‰ ë¸”ë£¨-ê·¸ë¦° ë°°í¬ ì™„ë£Œ!"

      # ============================================
      # Step 8: ì´ì „ íƒ€ê²Ÿ Deregister (ì„ íƒ)
      # ============================================
      - name: Deregister old targets (optional)
        if: success()
        continue-on-error: true
        run: |
          echo "ğŸ”„ Deregistering old targets..."

          OLD_TG_ARN=$([[ "${{ steps.detect.outputs.target_env }}" == "blue" ]] && \
            echo "${{ secrets.GREEN_TARGET_GROUP_ARN }}" || \
            echo "${{ secrets.BLUE_TARGET_GROUP_ARN }}")

          OLD_TARGETS=$(aws elbv2 describe-target-health \
            --target-group-arn $OLD_TG_ARN \
            --query 'TargetHealthDescriptions[].Target.Id' \
            --output text)

          if [[ -n "$OLD_TARGETS" ]]; then
            for TARGET in $OLD_TARGETS; do
              aws elbv2 deregister-targets \
                --target-group-arn $OLD_TG_ARN \
                --targets Id=$TARGET || true
              echo "âœ… Deregistered $TARGET"
            done
          fi

      # ============================================
      # ì •ë¦¬: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” Docker ì´ë¯¸ì§€ ì‚­ì œ
      # ============================================
      - name: Cleanup old Docker images
        if: success()
        run: |
          echo "ğŸ§¹ Cleaning up unused Docker images..."

          ssh -i ~/.ssh/codiit-key.pem ec2-user@${{ steps.get-ip.outputs.public_ip }} \
            "docker image prune -af --filter 'until=24h'"

          echo "âœ… Cleanup completed"

      # ============================================
      # ë¡¤ë°±: ë°°í¬ ì‹¤íŒ¨ ì‹œ íƒ€ê²Ÿ Deregister
      # ============================================
      - name: Rollback on failure
        if: failure()
        run: |
          echo "âŒ ë°°í¬ ì‹¤íŒ¨!"

          # ì‹¤íŒ¨í•œ íƒ€ê²Ÿ Deregister
          aws elbv2 deregister-targets \
            --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
            --targets Id=${{ steps.ec2-setup.outputs.instance_id }} || true

          echo "ğŸ’¡ ${{ steps.detect.outputs.current_env }} í™˜ê²½ì´ ê³„ì† ìš´ì˜ ì¤‘ì…ë‹ˆë‹¤."
          echo "ğŸ”„ ë¡¤ë°± ë¶ˆí•„ìš” (ALB ì „í™˜ ì „ ì‹¤íŒ¨)"
          echo ""
          echo "ë””ë²„ê¹… ì •ë³´:"
          echo "  Instance ID: ${{ steps.ec2-setup.outputs.instance_id }}"
          echo "  Public IP: ${{ steps.get-ip.outputs.public_ip }}"

      # ============================================
      # Discord ì•Œë¦¼
      # ============================================
      - name: Discord ë°°í¬ ì„±ê³µ ì•Œë¦¼
        if: success()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âœ… ë°°í¬ ì„±ê³µ!"
          description: |
            **ë¸Œëœì¹˜**: ${{ github.ref_name }}
            **ì»¤ë°‹**: ${{ github.event.head_commit.message }}
            **ì‘ì„±ì**: ${{ github.actor }}
            **í™˜ê²½**: ${{ steps.detect.outputs.target_env }}
            **ì¸ìŠ¤í„´ìŠ¤**: ${{ steps.ec2-setup.outputs.instance_id }}
            **ì›Œí¬í”Œë¡œìš°**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          color: 0x00FF00

      - name: Discord ë°°í¬ ì‹¤íŒ¨ ì•Œë¦¼
        if: failure()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âŒ ë°°í¬ ì‹¤íŒ¨!"
          description: |
            **ë¸Œëœì¹˜**: ${{ github.ref_name }}
            **ì»¤ë°‹**: ${{ github.event.head_commit.message }}
            **ì‘ì„±ì**: ${{ github.actor }}
            **í™˜ê²½**: ${{ steps.detect.outputs.target_env || 'unknown' }}
            **ë¡œê·¸**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          color: 0xFF0000
