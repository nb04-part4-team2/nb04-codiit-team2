name: Deploy to AWS (Deploy Branch)

on:
  push:
    branches:
      - deploy
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
        default: development

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}
  AMI_ID: ${{ secrets.AMI_ID }}
  SECURITY_GROUP_ID: ${{ secrets.SECURITY_GROUP_ID }}
  SUBNET_ID: ${{ secrets.SUBNET_ID }}
  IAM_INSTANCE_PROFILE: ${{ secrets.IAM_INSTANCE_PROFILE }}
  KEY_NAME: ${{ secrets.KEY_NAME }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ============================================
      # Step 1: í˜„ì¬ í™œì„± í™˜ê²½ ê°ì§€ (Blue/Green)
      # ============================================
      - name: Detect current active environment
        id: detect
        run: |
          echo "ğŸ” í˜„ì¬ ìš´ì˜ ì¤‘ì¸ í™˜ê²½ ê°ì§€ ì¤‘..."

          CURRENT_TG_ARN=$(aws elbv2 describe-listeners \
            --listener-arns ${{ secrets.ALB_LISTENER_ARN }} \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
            --output text)

          echo "Current Target Group: $CURRENT_TG_ARN"

          if [[ "$CURRENT_TG_ARN" == "${{ secrets.BLUE_TARGET_GROUP_ARN }}" ]]; then
            echo "current_env=blue" >> $GITHUB_OUTPUT
            echo "target_env=green" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-green" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.GREEN_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸ“˜ í˜„ì¬: Blue ìš´ì˜ ì¤‘ â†’ ğŸ“— ë°°í¬ íƒ€ê²Ÿ: Green"
          elif [[ "$CURRENT_TG_ARN" == "${{ secrets.GREEN_TARGET_GROUP_ARN }}" ]]; then
            echo "current_env=green" >> $GITHUB_OUTPUT
            echo "target_env=blue" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-blue" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸ“— í˜„ì¬: Green ìš´ì˜ ì¤‘ â†’ ğŸ“˜ ë°°í¬ íƒ€ê²Ÿ: Blue"
          else
            echo "âš ï¸ No active target group detected. Starting initial deployment."
            echo "current_env=none" >> $GITHUB_OUTPUT
            echo "target_env=blue" >> $GITHUB_OUTPUT
            echo "target_tag=codiit-blue" >> $GITHUB_OUTPUT
            echo "target_tg_arn=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_OUTPUT
            echo "ğŸš€ ì²« ë°°í¬: Blue í™˜ê²½ìœ¼ë¡œ ì‹œì‘"
          fi

      # ============================================
      # Step 2: EC2 ì¡´ì¬ í™•ì¸ ë° ìƒì„±
      # ============================================
      - name: Check or create EC2 instance
        id: ec2-setup
        run: |
          echo "ğŸ” Checking for existing ${{ steps.detect.outputs.target_tag }} EC2..."

          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ steps.detect.outputs.target_tag }}" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ "$INSTANCE_ID" == "None" || -z "$INSTANCE_ID" ]]; then
            echo "ğŸ”¨ Creating new EC2 from Golden AMI..."

            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ${{ secrets.AMI_ID }} \
              --instance-type t3.micro \
              --key-name ${{ env.KEY_NAME }} \
              --security-group-ids ${{ env.SECURITY_GROUP_ID }} \
              --subnet-id ${{ env.SUBNET_ID }} \
              --iam-instance-profile Name=${{ env.IAM_INSTANCE_PROFILE }} \
              --associate-public-ip-address \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${{ steps.detect.outputs.target_tag }}}]" \
              --query 'Instances[0].InstanceId' \
              --output text)

            echo "âœ… EC2 created: $INSTANCE_ID"
            echo "â³ Waiting for instance to be running..."
            aws ec2 wait instance-running --instance-ids $INSTANCE_ID

            # EC2 ì´ˆê¸°í™” ëŒ€ê¸° (90ì´ˆ)
            # ì´ìœ : ë¶€íŒ… í›„ Docker, AWS CLI, systemd ì„œë¹„ìŠ¤ê°€ ì™„ì „íˆ ì¤€ë¹„ë˜ê¸°ê¹Œì§€ 60-90ì´ˆ ì†Œìš”
            # Golden AMIì— ì´ë¯¸ ì„¤ì¹˜ë˜ì–´ ìˆì§€ë§Œ, ì„œë¹„ìŠ¤ ì‹œì‘ ë° ì´ˆê¸°í™” ì‹œê°„ ê³ ë ¤
            echo "â³ Waiting for initialization (90s)..."
            sleep 90
          else
            echo "âœ… Using existing EC2: $INSTANCE_ID"
          fi

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      # ============================================
      # Step 3: EC2 Public IP ë™ì  ì¡°íšŒ
      # ============================================
      - name: Get EC2 Public IP
        id: get-ip
        run: |
          echo "ğŸ” Getting Public IP for ${{ steps.ec2-setup.outputs.instance_id }}..."

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ steps.ec2-setup.outputs.instance_id }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "âœ… Public IP: $PUBLIC_IP"
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      # ============================================
      # Step 4: Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ECR í‘¸ì‹œ
      # ============================================
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                     $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "âœ… Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      # ============================================
      # Step 5: EC2ì— ë°°í¬ (SSH)
      # ============================================
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/codiit-key.pem
          chmod 400 ~/.ssh/codiit-key.pem
          ssh-keyscan -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Create .env file locally
        run: |
          echo "ğŸ“ Creating .env file locally..."
          cat > .env.production << 'EOF'
          NODE_ENV=production
          PORT=3000
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          ACCESS_TOKEN_SECRET=${{ secrets.ACCESS_TOKEN_SECRET }}
          ACCESS_TOKEN_EXPIRES_IN=15m
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          REFRESH_TOKEN_EXPIRES_IN=7d
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          BCRYPT_ROUNDS=10
          AWS_REGION=ap-northeast-2
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          PORTONE_API_KEY=${{ secrets.PORTONE_API_KEY }}
          PORTONE_API_SECRET=${{ secrets.PORTONE_API_SECRET }}
          EOF
          echo "âœ… .env file created"

      - name: Transfer .env to EC2
        run: |
          echo "ğŸ“¤ Transferring .env to ${{ steps.detect.outputs.target_env }} EC2..."
          scp -i ~/.ssh/codiit-key.pem .env.production \
            ec2-user@${{ steps.get-ip.outputs.public_ip }}:/home/ec2-user/.env

          # ë¡œì»¬ .env ì‚­ì œ (ë³´ì•ˆ)
          rm -f .env.production

          echo "âœ… .env file transferred securely"

      - name: Deploy Docker container on ${{ steps.detect.outputs.target_env }} EC2
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "ğŸš€ Deploying to ${{ steps.detect.outputs.target_env }} EC2..."

          ssh -i ~/.ssh/codiit-key.pem ec2-user@${{ steps.get-ip.outputs.public_ip }} \
            "AWS_REGION=${AWS_REGION} \
             ECR_REGISTRY=${ECR_REGISTRY} \
             ECR_REPOSITORY=${ECR_REPOSITORY} \
             IMAGE_TAG=${IMAGE_TAG} \
             bash -s" << 'DEPLOYSSH'
          # ECR ë¡œê·¸ì¸
          aws ecr get-login-password --region $AWS_REGION | \
            docker login --username AWS --password-stdin $ECR_REGISTRY

          # ì´ë¯¸ì§€ Pull
          echo "ğŸ“¥ Pulling new image..."
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ Graceful Shutdown
          # íƒ€ì„ì•„ì›ƒ: 30ì´ˆ (Node.js Graceful Shutdown ì‹œê°„)
          # src/server.tsì˜ gracefulShutdown íƒ€ì„ì•„ì›ƒê³¼ ë™ì¼í•˜ê²Œ ì„¤ì •
          # SSE ì—°ê²° ì¢…ë£Œ + HTTP ì„œë²„ ì¢…ë£Œ + DB ì—°ê²° ì¢…ë£Œ ì‹œê°„ ê³ ë ¤
          echo "ğŸ›‘ Stopping old container (30s graceful)..."
          docker stop --time 30 app || true
          docker rm app || true

          # ìƒˆ ì»¨í…Œì´ë„ˆ ì‹¤í–‰
          echo "â–¶ï¸  Starting new container..."
          docker run -d \
            --name app \
            -p 3000:3000 \
            --restart=always \
            --env-file /home/ec2-user/.env \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          # Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
          echo "ğŸ”„ Running Prisma migrations..."
          docker exec app npx prisma migrate deploy

          if [ $? -ne 0 ]; then
            echo "âŒ Migration failed!"
            echo ""
            echo "ğŸ” Debugging information:"
            echo "  Container status:"
            docker ps -a | grep app || true
            echo ""
            echo "  Container logs (last 50 lines):"
            docker logs app --tail 50 || true
            docker stop app
            docker rm app
            exit 1
          fi
          echo "âœ… Migrations completed"

          # ============================================
          # í—¬ìŠ¤ì²´í¬ 1: EC2 ë‚´ë¶€ ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
          # íƒ€ì„ì•„ì›ƒ: 60ì´ˆ (12íšŒ * 5ì´ˆ)
          # ëª©ì : ì•±ì´ ì •ìƒì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
          # ============================================
          echo "ğŸ¥ Health checking (local)..."
          for i in {1..12}; do
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "âœ… Local health check passed! ($i/12 = $((i*5))s elapsed)"

              # ECR ë¡œê·¸ì•„ì›ƒ (ë³´ì•ˆ)
              echo "ğŸ”“ Logging out from ECR..."
              docker logout $ECR_REGISTRY || true

              exit 0
            fi

            if [ $i -eq 12 ]; then
              echo "âŒ Local health check failed after 60s"
              echo ""
              echo "ğŸ” Debugging information:"
              echo "  Container status:"
              docker ps -a | grep app || true
              echo ""
              echo "  Container logs (last 50 lines):"
              docker logs app --tail 50 || true
              echo ""
              echo "  Health endpoint test:"
              curl -v http://localhost:3000/api/health || true
              exit 1
            fi

            echo "   â³ Retrying... ($i/12 = $((i*5))s elapsed)"
            sleep 5
          done
          DEPLOYSSH

          echo "âœ… Deployment on ${{ steps.detect.outputs.target_env }} EC2 successful!"

      # ============================================
      # Step 6: Target Groupì— EC2 ë“±ë¡
      # ============================================
      - name: Register to Target Group
        run: |
          echo "ğŸ“‹ Registering to Target Group..."

          EXISTING=$(aws elbv2 describe-target-health \
            --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
            --query "TargetHealthDescriptions[?Target.Id=='${{ steps.ec2-setup.outputs.instance_id }}'].Target.Id" \
            --output text)

          if [[ -z "$EXISTING" ]]; then
            aws elbv2 register-targets \
              --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
              --targets Id=${{ steps.ec2-setup.outputs.instance_id }}
            echo "âœ… Target registered"
          else
            echo "â„¹ï¸  Target already registered"
          fi

      # ============================================
      # í—¬ìŠ¤ì²´í¬ 2: ALB Target Group í—¬ìŠ¤ì²´í¬
      # íƒ€ì„ì•„ì›ƒ: 120ì´ˆ (12íšŒ * 10ì´ˆ)
      # ëª©ì : ALBê°€ íƒ€ê²Ÿì„ healthy/unusedë¡œ ì¸ì‹í•˜ëŠ”ì§€ í™•ì¸
      # unused = Blue-Greenì—ì„œ ëŒ€ê¸° ì¤‘ (ì •ìƒ ìƒíƒœ)
      # ============================================
      - name: Wait for target to be healthy
        run: |
          echo "â³ Waiting for target to be healthy (ALB level)..."

          for i in {1..12}; do
            HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
              --targets Id=${{ steps.ec2-setup.outputs.instance_id }} \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)

            echo "Target health: $HEALTH ($i/12 = $((i*10))s elapsed)"

            # Blue-Green ë°°í¬ì—ì„œ ë¹„í™œì„± Target Groupì€ 'unused' ìƒíƒœê°€ ì •ìƒ
            # ALBê°€ í•´ë‹¹ TGë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ Health Checkê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
            # 'unused'ëŠ” ë°°í¬ ì‹¤íŒ¨ê°€ ì•„ë‹ˆë¼ "ëŒ€ê¸° ì¤‘" ìƒíƒœë¥¼ ì˜ë¯¸
            if [[ "$HEALTH" == "healthy" ]] || [[ "$HEALTH" == "unused" ]]; then
              echo "âœ… Target is ready! (Status: $HEALTH)"
              exit 0
            fi

            sleep 10
          done

          echo "âŒ Target did not become healthy"
          echo ""
          echo "ğŸ” Target Group ìƒíƒœ:"
          aws elbv2 describe-target-health \
            --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
            --targets Id=${{ steps.ec2-setup.outputs.instance_id }} \
            --output table || true
          exit 1

      # ============================================
      # Step 7: ALB íŠ¸ë˜í”½ ì „í™˜
      # ============================================
      - name: Switch ALB to ${{ steps.detect.outputs.target_env }}
        if: success()
        run: |
          echo "ğŸ”€ ALB íŠ¸ë˜í”½ ì „í™˜ ì¤‘..."
          echo "   ${{ steps.detect.outputs.current_env }} â†’ ${{ steps.detect.outputs.target_env }}"

          # HTTP Listener (80) ì „í™˜
          echo "ğŸŒ HTTP Listener (80) ì „í™˜ ì¤‘..."
          aws elbv2 modify-listener \
            --listener-arn ${{ secrets.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ steps.detect.outputs.target_tg_arn }}
          echo "âœ… HTTP Listener ì „í™˜ ì™„ë£Œ"

          # HTTPS Listener (443) ì „í™˜
          echo "ğŸ”’ HTTPS Listener (443) ì „í™˜ ì¤‘..."
          aws elbv2 modify-listener \
            --listener-arn ${{ secrets.ALB_LISTENER_HTTPS_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ steps.detect.outputs.target_tg_arn }}
          echo "âœ… HTTPS Listener ì „í™˜ ì™„ë£Œ"

          echo ""
          echo "âœ… ëª¨ë“  íŠ¸ë˜í”½ ì „í™˜ ì™„ë£Œ! (HTTP + HTTPS)"
          echo ""
          echo "ğŸ“Š ë°°í¬ ê²°ê³¼:"
          echo "   â€¢ ì´ì „: ${{ steps.detect.outputs.current_env }} (ë¡¤ë°± ëŒ€ê¸°)"
          echo "   â€¢ í˜„ì¬: ${{ steps.detect.outputs.target_env }} (ìš´ì˜ ì¤‘)"
          echo "   â€¢ Instance: ${{ steps.ec2-setup.outputs.instance_id }}"
          echo "   â€¢ IP: ${{ steps.get-ip.outputs.public_ip }}"
          echo "   â€¢ Image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
          echo ""
          echo "ğŸ‰ ë¸”ë£¨-ê·¸ë¦° ë°°í¬ ì™„ë£Œ!"

      # ============================================
      # Step 8: ì´ì „ íƒ€ê²Ÿ Deregister (ë¹„í™œì„±í™”)
      # ============================================
      # ì£¼ì„ ì²˜ë¦¬ ì´ìœ : ì¦‰ì‹œ ë¡¤ë°±ì„ ìœ„í•´ Standby í™˜ê²½ì„ Target Groupì— ìœ ì§€
      # Blue-Green ë°°í¬ì—ì„œ ë¹„í™œì„± í™˜ê²½ë„ ë“±ë¡ ìƒíƒœ ìœ ì§€ â†’ 1ì´ˆ ë¡¤ë°± ê°€ëŠ¥
      #
      # - name: Deregister old targets (optional)
      #   if: success()
      #   continue-on-error: true
      #   run: |
      #     echo "ğŸ”„ Deregistering old targets..."
      #
      #     OLD_TG_ARN=$([[ "${{ steps.detect.outputs.target_env }}" == "blue" ]] && \
      #       echo "${{ secrets.GREEN_TARGET_GROUP_ARN }}" || \
      #       echo "${{ secrets.BLUE_TARGET_GROUP_ARN }}")
      #
      #     OLD_TARGETS=$(aws elbv2 describe-target-health \
      #       --target-group-arn $OLD_TG_ARN \
      #       --query 'TargetHealthDescriptions[].Target.Id' \
      #       --output text)
      #
      #     if [[ -n "$OLD_TARGETS" ]]; then
      #       for TARGET in $OLD_TARGETS; do
      #         aws elbv2 deregister-targets \
      #           --target-group-arn $OLD_TG_ARN \
      #           --targets Id=$TARGET || true
      #         echo "âœ… Deregistered $TARGET"
      #       done
      #     fi

      # ============================================
      # ì •ë¦¬: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” Docker ì´ë¯¸ì§€ ì‚­ì œ
      # ============================================
      - name: Cleanup old Docker images
        if: success()
        run: |
          echo "ğŸ§¹ Cleaning up unused Docker images..."

          # 24ì‹œê°„ ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì´ë¯¸ì§€ë§Œ ì‚­ì œ
          # ì´ìœ : Blue-Green ë°°í¬ ì‹œ ì´ì „ ë²„ì „ ì´ë¯¸ì§€ ë³´ì¡´ (ë¹ ë¥¸ ë¡¤ë°±)
          # 24ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì•ˆì „ì„±ê³¼ ë””ìŠ¤í¬ ê³µê°„ ê´€ë¦¬ ê· í˜• ìœ ì§€
          ssh -i ~/.ssh/codiit-key.pem ec2-user@${{ steps.get-ip.outputs.public_ip }} \
            "docker image prune -af --filter 'until=24h'"

          echo "âœ… Cleanup completed"

      # ============================================
      # ë¡¤ë°±: ë°°í¬ ì‹¤íŒ¨ ì‹œ íƒ€ê²Ÿ Deregister
      # ============================================
      - name: Rollback on failure
        if: failure()
        run: |
          echo "âŒ ë°°í¬ ì‹¤íŒ¨!"

          # ì‹¤íŒ¨í•œ íƒ€ê²Ÿ Deregister
          aws elbv2 deregister-targets \
            --target-group-arn ${{ steps.detect.outputs.target_tg_arn }} \
            --targets Id=${{ steps.ec2-setup.outputs.instance_id }} || true

          echo "ğŸ’¡ ${{ steps.detect.outputs.current_env }} í™˜ê²½ì´ ê³„ì† ìš´ì˜ ì¤‘ì…ë‹ˆë‹¤."
          echo "ğŸ”„ ë¡¤ë°± ë¶ˆí•„ìš” (ALB ì „í™˜ ì „ ì‹¤íŒ¨)"
          echo ""
          echo "ë””ë²„ê¹… ì •ë³´:"
          echo "  Instance ID: ${{ steps.ec2-setup.outputs.instance_id }}"
          echo "  Public IP: ${{ steps.get-ip.outputs.public_ip }}"

      # ============================================
      # Discord ì•Œë¦¼
      # ============================================
      - name: Send Discord notification on success
        if: success()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âœ… ë°°í¬ ì„±ê³µ!"
          description: |
            - ğŸŒ¿ **ë¸Œëœì¹˜**: ${{ github.ref_name }}
            - ğŸ”„ **ë°°í¬ ì „í™˜**: ${{ steps.detect.outputs.current_env }} â†’ ${{ steps.detect.outputs.target_env }}
            - ğŸŒ **ìš´ì˜ í™˜ê²½**: ${{ steps.detect.outputs.target_env }} (Active)
            - ğŸ–¥ï¸ **ì¸ìŠ¤í„´ìŠ¤**: ${{ steps.ec2-setup.outputs.instance_id }}
          color: 0x00FF00

      - name: Send Discord notification on failure
        if: failure()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âŒ ë°°í¬ ì‹¤íŒ¨!"
          description: |
            - ğŸŒ¿ **ë¸Œëœì¹˜**: ${{ github.ref_name }}
            - ğŸ”„ **ë°°í¬ ì‹œë„**: ${{ steps.detect.outputs.current_env }} â†’ ${{ steps.detect.outputs.target_env }}
            - ğŸŒ **ì‹¤íŒ¨ í™˜ê²½**: ${{ steps.detect.outputs.target_env || 'unknown' }}
            - ğŸ–¥ï¸ **ì¸ìŠ¤í„´ìŠ¤**: ${{ steps.ec2-setup.outputs.instance_id || 'N/A' }}
          color: 0xFF0000
